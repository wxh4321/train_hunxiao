# train_hunxiao
现在假设待加密的代码段为A，额外添加的反调试代码块为B，自毁代码块为C。并假设，加密壳将A拆分为3段加密，将B、C各拆分为两段加密，这样共有7个加密代码段和7个相应的掩码段。我们假设加密代码段A_2与B_1共用掩码，A_3与C_2共用掩码，则共使用5个掩码，记为M_1至M_5。加密代码与掩码对应如下：

A_1 --- M_2

A_2 --- M_5

A_3 --- M_1

B_1 --- M_5

B_2 --- M_4

C_1 --- M_3

C_2 --- M_1

现在创建一个大小为12的数组Ar，将上述元素置乱后写入数组中，如下：

Ar={M_3, C_2, B_1, M_1, A_2, M_4, M_2, A_1, B_2, M_5, C_1, A_3}


于是，为了让神经网络能够引导程序从Ar中顺序提取出B---A(当完整性校验正常)/C(当完整性校验失败)，我们需要作出如下训练样本：

输入结构为：当前加密代码位置（以Ar数组下标的形式给出，下同），当前掩码位置，被校验代码内容（此处仅以用R代表校验正常，W代表校验异常，不涉及具体被校验数值）
输出结构为：下一组加密代码位置，下一组掩码位置，下一个被校验代码位置（简便起见，本例中以P_i代指之）
额外：以Init代表神经网络预定应该在第一次调用时所接受到的初始值，同样以R/W表示正常/异常

则训练样本为
输入	输出
2， 9， R(Init)	8， 5， P_0

8， 5， R(P_0)	7， 6， P_1

7， 6， R(P_1)	4， 9， P_2

4， 9， R(P_2)	11，3， P_3

10，0，  任意	1， 3，任意

其他所有case	10，0，任意

若神经网络经过训练后符合上述样本描述的行为，则可以正确完成前述引导（可以自己推演一下）
